// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `agent.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __agent_h__
#define __agent_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace DataPool
{

class InitParamManager;
class InitParamPool;
class Manager;
class ManagerPrx;
class Pool;
class PoolPrx;
class SubBatchPool;
class SubBatchPoolPrx;

}

namespace DataPool
{

using StringSeq = ::std::vector<::std::string>;

using StringMap = ::std::map<::std::string, ::std::string>;

constexpr int rpcPortDataServer = 21000;

struct PoolInfo
{
    ::std::string host;
    int port;

    std::tuple<const ::std::string&, const int&> ice_tuple() const
    {
        return std::tie(host, port);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace DataPool
{

class Manager : public virtual ::Ice::Object
{
public:

    using ProxyType = ManagerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual ::DataPool::PoolInfo createPool(::std::shared_ptr<::DataPool::InitParamPool>, const ::Ice::Current&) = 0;
    bool _iceD_createPool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void closePool(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_closePool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class Pool : public virtual ::Ice::Object
{
public:

    using ProxyType = PoolPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current&) = 0;
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual int getPid(const ::Ice::Current&) = 0;
    bool _iceD_getPid(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class SubBatchPool : public virtual ::Ice::Object
{
public:

    using ProxyType = SubBatchPoolPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();
};

}

namespace DataPool
{

class InitParamManager : public ::Ice::ValueHelper<InitParamManager, Ice::Value>
{
public:

    virtual ~InitParamManager();

    InitParamManager() = default;

    InitParamManager(const InitParamManager&) = default;
    InitParamManager(InitParamManager&&) = default;
    InitParamManager& operator=(const InitParamManager&) = default;
    InitParamManager& operator=(InitParamManager&&) = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

static InitParamManager _iceS_InitParamManager_init;

class InitParamPool : public ::Ice::ValueHelper<InitParamPool, Ice::Value>
{
public:

    virtual ~InitParamPool();

    InitParamPool() = default;

    InitParamPool(const InitParamPool&) = default;
    InitParamPool(InitParamPool&&) = default;
    InitParamPool& operator=(const InitParamPool&) = default;
    InitParamPool& operator=(InitParamPool&&) = default;

    InitParamPool(const ::std::string& iceP_name, int iceP_size, int iceP_subBatchSize, bool iceP_isTrain, const ::std::string& iceP_dataioHost, int iceP_dataioPort, const ::DataPool::StringSeq& iceP_trainTargets, const ::DataPool::StringMap& iceP_kwargs, bool iceP_isContinue) :
        name(::std::move(iceP_name)),
        size(iceP_size),
        subBatchSize(iceP_subBatchSize),
        isTrain(iceP_isTrain),
        dataioHost(::std::move(iceP_dataioHost)),
        dataioPort(iceP_dataioPort),
        trainTargets(::std::move(iceP_trainTargets)),
        kwargs(::std::move(iceP_kwargs)),
        isContinue(iceP_isContinue)
    {
    }

    std::tuple<const ::std::string&, const int&, const int&, const bool&, const ::std::string&, const int&, const ::DataPool::StringSeq&, const ::DataPool::StringMap&, const bool&> ice_tuple() const
    {
        return std::tie(name, size, subBatchSize, isTrain, dataioHost, dataioPort, trainTargets, kwargs, isContinue);
    }

    static const ::std::string& ice_staticId();

    ::std::string name;
    int size;
    int subBatchSize;
    bool isTrain;
    ::std::string dataioHost;
    int dataioPort;
    ::DataPool::StringSeq trainTargets;
    ::DataPool::StringMap kwargs;
    bool isContinue = false;
};

}

namespace DataPool
{

class ManagerPrx : public virtual ::Ice::Proxy<ManagerPrx, ::Ice::ObjectPrx>
{
public:

    ::DataPool::PoolInfo createPool(const ::std::shared_ptr<::DataPool::InitParamPool>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::DataPool::PoolInfo>(true, this, &DataPool::ManagerPrx::_iceI_createPool, iceP_param, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto createPoolAsync(const ::std::shared_ptr<::DataPool::InitParamPool>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::DataPool::PoolInfo>>().get_future())
    {
        return _makePromiseOutgoing<::DataPool::PoolInfo, P>(false, this, &DataPool::ManagerPrx::_iceI_createPool, iceP_param, context);
    }

    ::std::function<void()>
    createPoolAsync(const ::std::shared_ptr<::DataPool::InitParamPool>& iceP_param,
                    ::std::function<void(::DataPool::PoolInfo)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::DataPool::PoolInfo>(response, ex, sent, this, &DataPool::ManagerPrx::_iceI_createPool, iceP_param, context);
    }

    void _iceI_createPool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::DataPool::PoolInfo>>&, const ::std::shared_ptr<::DataPool::InitParamPool>&, const ::Ice::Context&);

    void closePool(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DataPool::ManagerPrx::_iceI_closePool, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto closePoolAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DataPool::ManagerPrx::_iceI_closePool, iceP_name, context);
    }

    ::std::function<void()>
    closePoolAsync(const ::std::string& iceP_name,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &DataPool::ManagerPrx::_iceI_closePool, iceP_name, context);
    }

    void _iceI_closePool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    ManagerPrx() = default;
    friend ::std::shared_ptr<ManagerPrx> IceInternal::createProxy<ManagerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class PoolPrx : public virtual ::Ice::Proxy<PoolPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DataPool::PoolPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DataPool::PoolPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &DataPool::PoolPrx::_iceI_shutdown, context);
    }

    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);

    int getPid(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &DataPool::PoolPrx::_iceI_getPid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getPidAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &DataPool::PoolPrx::_iceI_getPid, context);
    }

    ::std::function<void()>
    getPidAsync(::std::function<void(int)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &DataPool::PoolPrx::_iceI_getPid, context);
    }

    void _iceI_getPid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    PoolPrx() = default;
    friend ::std::shared_ptr<PoolPrx> IceInternal::createProxy<PoolPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class SubBatchPoolPrx : public virtual ::Ice::Proxy<SubBatchPoolPrx, ::Ice::ObjectPrx>
{
public:

    static const ::std::string& ice_staticId();

protected:

    SubBatchPoolPrx() = default;
    friend ::std::shared_ptr<SubBatchPoolPrx> IceInternal::createProxy<SubBatchPoolPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

template<>
struct StreamableTraits<::DataPool::PoolInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::DataPool::PoolInfo, S>
{
    static void read(S* istr, ::DataPool::PoolInfo& v)
    {
        istr->readAll(v.host, v.port);
    }
};

template<typename S>
struct StreamReader<::DataPool::InitParamPool, S>
{
    static void read(S* istr, ::DataPool::InitParamPool& v)
    {
        istr->readAll(v.name, v.size, v.subBatchSize, v.isTrain, v.dataioHost, v.dataioPort, v.trainTargets, v.kwargs, v.isContinue);
    }
};

}

namespace DataPool
{

using InitParamManagerPtr = ::std::shared_ptr<InitParamManager>;

using InitParamPoolPtr = ::std::shared_ptr<InitParamPool>;

using ManagerPtr = ::std::shared_ptr<Manager>;
using ManagerPrxPtr = ::std::shared_ptr<ManagerPrx>;

using PoolPtr = ::std::shared_ptr<Pool>;
using PoolPrxPtr = ::std::shared_ptr<PoolPrx>;

using SubBatchPoolPtr = ::std::shared_ptr<SubBatchPool>;
using SubBatchPoolPrxPtr = ::std::shared_ptr<SubBatchPoolPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace DataPool
{

class InitParamManager;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataPool::InitParamManager>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataPool::InitParamManager*);

class InitParamPool;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataPool::InitParamPool>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataPool::InitParamPool*);

class Manager;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataPool::Manager>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataPool::Manager*);

class Pool;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataPool::Pool>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataPool::Pool*);

class SubBatchPool;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataPool::SubBatchPool>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataPool::SubBatchPool*);

}

}

namespace DataPool
{

class InitParamManager;
::Ice::Object* upCast(::DataPool::InitParamManager*);
typedef ::IceInternal::Handle< ::DataPool::InitParamManager> InitParamManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataPool::InitParamManager> InitParamManagerPrx;
typedef InitParamManagerPrx InitParamManagerPrxPtr;
void _icePatchObjectPtr(InitParamManagerPtr&, const ::Ice::ObjectPtr&);

class InitParamPool;
::Ice::Object* upCast(::DataPool::InitParamPool*);
typedef ::IceInternal::Handle< ::DataPool::InitParamPool> InitParamPoolPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataPool::InitParamPool> InitParamPoolPrx;
typedef InitParamPoolPrx InitParamPoolPrxPtr;
void _icePatchObjectPtr(InitParamPoolPtr&, const ::Ice::ObjectPtr&);

class Manager;
::Ice::Object* upCast(::DataPool::Manager*);
typedef ::IceInternal::Handle< ::DataPool::Manager> ManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataPool::Manager> ManagerPrx;
typedef ManagerPrx ManagerPrxPtr;
void _icePatchObjectPtr(ManagerPtr&, const ::Ice::ObjectPtr&);

class Pool;
::Ice::Object* upCast(::DataPool::Pool*);
typedef ::IceInternal::Handle< ::DataPool::Pool> PoolPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataPool::Pool> PoolPrx;
typedef PoolPrx PoolPrxPtr;
void _icePatchObjectPtr(PoolPtr&, const ::Ice::ObjectPtr&);

class SubBatchPool;
::Ice::Object* upCast(::DataPool::SubBatchPool*);
typedef ::IceInternal::Handle< ::DataPool::SubBatchPool> SubBatchPoolPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataPool::SubBatchPool> SubBatchPoolPrx;
typedef SubBatchPoolPrx SubBatchPoolPrxPtr;
void _icePatchObjectPtr(SubBatchPoolPtr&, const ::Ice::ObjectPtr&);

}

namespace DataPool
{

typedef ::std::vector< ::std::string> StringSeq;

typedef ::std::map< ::std::string, ::std::string> StringMap;

const ::Ice::Int rpcPortDataServer = 21000;

struct PoolInfo
{
    ::std::string host;
    ::Ice::Int port;

    bool operator==(const PoolInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(host != rhs_.host)
        {
            return false;
        }
        if(port != rhs_.port)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PoolInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(host < rhs_.host)
        {
            return true;
        }
        else if(rhs_.host < host)
        {
            return false;
        }
        if(port < rhs_.port)
        {
            return true;
        }
        else if(rhs_.port < port)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PoolInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const PoolInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const PoolInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const PoolInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace DataPool
{

class Callback_Manager_createPool_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Manager_createPool_Base> Callback_Manager_createPoolPtr;

class Callback_Manager_closePool_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Manager_closePool_Base> Callback_Manager_closePoolPtr;

class Callback_Pool_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Pool_shutdown_Base> Callback_Pool_shutdownPtr;

class Callback_Pool_getPid_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Pool_getPid_Base> Callback_Pool_getPidPtr;

}

namespace IceProxy
{

namespace DataPool
{

class InitParamManager : public virtual ::Ice::Proxy<InitParamManager, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class InitParamPool : public virtual ::Ice::Proxy<InitParamPool, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Manager : public virtual ::Ice::Proxy<Manager, ::IceProxy::Ice::Object>
{
public:

    ::DataPool::PoolInfo createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_createPool(_iceI_begin_createPool(iceP_param, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_createPool(iceP_param, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createPool(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createPool(iceP_param, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::DataPool::Callback_Manager_createPoolPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createPool(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_createPool(const ::DataPool::InitParamPoolPtr& iceP_param, const ::Ice::Context& context, const ::DataPool::Callback_Manager_createPoolPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createPool(iceP_param, context, del, cookie);
    }

    ::DataPool::PoolInfo end_createPool(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_createPool(const ::DataPool::InitParamPoolPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void closePool(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_closePool(_iceI_begin_closePool(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_closePool(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_closePool(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closePool(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_closePool(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_closePool(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_closePool(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_closePool(const ::std::string& iceP_name, const ::DataPool::Callback_Manager_closePoolPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_closePool(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_closePool(const ::std::string& iceP_name, const ::Ice::Context& context, const ::DataPool::Callback_Manager_closePoolPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_closePool(iceP_name, context, del, cookie);
    }

    void end_closePool(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_closePool(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Pool : public virtual ::Ice::Proxy<Pool, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::DataPool::Callback_Pool_shutdownPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::DataPool::Callback_Pool_shutdownPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, del, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getPid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPid(_iceI_begin_getPid(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPid(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPid(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPid(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPid(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPid(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPid(const ::DataPool::Callback_Pool_getPidPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPid(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPid(const ::Ice::Context& context, const ::DataPool::Callback_Pool_getPidPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPid(context, del, cookie);
    }

    ::Ice::Int end_getPid(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPid(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class SubBatchPool : public virtual ::Ice::Proxy<SubBatchPool, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace DataPool
{

class InitParamManager : public virtual ::Ice::Object
{
public:

    typedef InitParamManagerPrx ProxyType;
    typedef InitParamManagerPtr PointerType;

    virtual ~InitParamManager();

    InitParamManager()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};
static ::Ice::ValueFactoryPtr _iceS_InitParamManager_init = ::DataPool::InitParamManager::ice_factory();

inline bool operator==(const InitParamManager& lhs, const InitParamManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const InitParamManager& lhs, const InitParamManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class InitParamPool : public virtual ::Ice::Object
{
public:

    typedef InitParamPoolPrx ProxyType;
    typedef InitParamPoolPtr PointerType;

    virtual ~InitParamPool();

    InitParamPool() :
        isContinue(false)
    {
    }

    InitParamPool(const ::std::string& iceP_name, ::Ice::Int iceP_size, ::Ice::Int iceP_subBatchSize, bool iceP_isTrain, const ::std::string& iceP_dataioHost, ::Ice::Int iceP_dataioPort, const ::DataPool::StringSeq& iceP_trainTargets, const ::DataPool::StringMap& iceP_kwargs, bool iceP_isContinue) :
        name(iceP_name),
        size(iceP_size),
        subBatchSize(iceP_subBatchSize),
        isTrain(iceP_isTrain),
        dataioHost(iceP_dataioHost),
        dataioPort(iceP_dataioPort),
        trainTargets(iceP_trainTargets),
        kwargs(iceP_kwargs),
        isContinue(iceP_isContinue)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::std::string name;
    ::Ice::Int size;
    ::Ice::Int subBatchSize;
    bool isTrain;
    ::std::string dataioHost;
    ::Ice::Int dataioPort;
    ::DataPool::StringSeq trainTargets;
    ::DataPool::StringMap kwargs;
    bool isContinue;
};
static ::Ice::ValueFactoryPtr _iceS_InitParamPool_init = ::DataPool::InitParamPool::ice_factory();

inline bool operator==(const InitParamPool& lhs, const InitParamPool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const InitParamPool& lhs, const InitParamPool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Manager : public virtual ::Ice::Object
{
public:

    typedef ManagerPrx ProxyType;
    typedef ManagerPtr PointerType;

    virtual ~Manager();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual ::DataPool::PoolInfo createPool(const ::DataPool::InitParamPoolPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_createPool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void closePool(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_closePool(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Manager& lhs, const Manager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Manager& lhs, const Manager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Pool : public virtual ::Ice::Object
{
public:

    typedef PoolPrx ProxyType;
    typedef PoolPtr PointerType;

    virtual ~Pool();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getPid(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getPid(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Pool& lhs, const Pool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Pool& lhs, const Pool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class SubBatchPool : public virtual ::Ice::Object
{
public:

    typedef SubBatchPoolPrx ProxyType;
    typedef SubBatchPoolPtr PointerType;

    virtual ~SubBatchPool();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const SubBatchPool& lhs, const SubBatchPool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SubBatchPool& lhs, const SubBatchPool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<>
struct StreamableTraits< ::DataPool::PoolInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::DataPool::PoolInfo, S>
{
    static void write(S* ostr, const ::DataPool::PoolInfo& v)
    {
        ostr->write(v.host);
        ostr->write(v.port);
    }
};

template<typename S>
struct StreamReader< ::DataPool::PoolInfo, S>
{
    static void read(S* istr, ::DataPool::PoolInfo& v)
    {
        istr->read(v.host);
        istr->read(v.port);
    }
};

template<typename S>
struct StreamWriter< ::DataPool::InitParamPool, S>
{
    static void write(S* ostr, const ::DataPool::InitParamPool& v)
    {
        ostr->write(v.name);
        ostr->write(v.size);
        ostr->write(v.subBatchSize);
        ostr->write(v.isTrain);
        ostr->write(v.dataioHost);
        ostr->write(v.dataioPort);
        ostr->write(v.trainTargets);
        ostr->write(v.kwargs);
        ostr->write(v.isContinue);
    }
};

template<typename S>
struct StreamReader< ::DataPool::InitParamPool, S>
{
    static void read(S* istr, ::DataPool::InitParamPool& v)
    {
        istr->read(v.name);
        istr->read(v.size);
        istr->read(v.subBatchSize);
        istr->read(v.isTrain);
        istr->read(v.dataioHost);
        istr->read(v.dataioPort);
        istr->read(v.trainTargets);
        istr->read(v.kwargs);
        istr->read(v.isContinue);
    }
};

}

namespace DataPool
{

template<class T>
class CallbackNC_Manager_createPool : public Callback_Manager_createPool_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::DataPool::PoolInfo&);

    CallbackNC_Manager_createPool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataPool::ManagerPrx proxy = ::DataPool::ManagerPrx::uncheckedCast(result->getProxy());
        ::DataPool::PoolInfo ret;
        try
        {
            ret = proxy->end_createPool(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Manager_createPoolPtr
newCallback_Manager_createPool(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataPool::PoolInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_createPool<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Manager_createPoolPtr
newCallback_Manager_createPool(T* instance, void (T::*cb)(const ::DataPool::PoolInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_createPool<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Manager_createPool : public Callback_Manager_createPool_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::DataPool::PoolInfo&, const CT&);

    Callback_Manager_createPool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataPool::ManagerPrx proxy = ::DataPool::ManagerPrx::uncheckedCast(result->getProxy());
        ::DataPool::PoolInfo ret;
        try
        {
            ret = proxy->end_createPool(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Manager_createPoolPtr
newCallback_Manager_createPool(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataPool::PoolInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_createPool<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Manager_createPoolPtr
newCallback_Manager_createPool(T* instance, void (T::*cb)(const ::DataPool::PoolInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_createPool<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Manager_closePool : public Callback_Manager_closePool_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Manager_closePool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_closePool<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_closePool<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_closePool<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Manager_closePool<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Manager_closePool : public Callback_Manager_closePool_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Manager_closePool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_closePool<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_closePool<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_closePool<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Manager_closePoolPtr
newCallback_Manager_closePool(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Manager_closePool<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Pool_shutdown : public Callback_Pool_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Pool_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Pool_shutdown : public Callback_Pool_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Pool_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_shutdownPtr
newCallback_Pool_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Pool_getPid : public Callback_Pool_getPid_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Pool_getPid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataPool::PoolPrx proxy = ::DataPool::PoolPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getPid(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Pool_getPidPtr
newCallback_Pool_getPid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_getPid<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_getPidPtr
newCallback_Pool_getPid(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_getPid<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Pool_getPid : public Callback_Pool_getPid_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Pool_getPid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataPool::PoolPrx proxy = ::DataPool::PoolPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getPid(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Pool_getPidPtr
newCallback_Pool_getPid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_getPid<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_getPidPtr
newCallback_Pool_getPid(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_getPid<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif

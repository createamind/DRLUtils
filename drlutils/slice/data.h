// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `data.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __data_h__
#define __data_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/Identity.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace DataFlow
{

class NDArray;
class IOData;
class IODataPut;
class IODataGet;
class IOStreamParam;
class IOStream;
class IOStreamPrx;
class ObjectBase;
class InitServerParams;
class DSStatus;
class TensorInfo;
class TensorInfos;
class PacketStatistic;
class BatchDataProcessorStatus;
class DataServer;
class DataServerPrx;
class EvtEpoch;
class BatchDataProcessor;
class BatchDataProcessorPrx;

}

namespace DataFlow
{

using ByteSeq = ::std::vector<::Ice::Byte>;

using Shape = ::std::vector<int>;

using FloatSeq = ::std::vector<float>;

using IntSeq = ::std::vector<int>;

using StringSeq = ::std::vector<::std::string>;

enum class NDType : unsigned char
{
    ndtFloat32 = 0,
    ndtUint8 = 1,
    ndtInt32 = 2,
    ndtInt64 = 3,
    ndtUnknown = 4
};

using NDArrayList = ::std::vector<::std::shared_ptr<::DataFlow::NDArray>>;

using NDArrayMap = ::std::map<::std::string, ::std::shared_ptr<::DataFlow::NDArray>>;

using TensorList = ::std::vector<::std::shared_ptr<::DataFlow::NDArray>>;

using TensorMap = ::std::map<::std::string, ::std::shared_ptr<::DataFlow::NDArray>>;

using EventParamMap = ::std::map<::std::string, ::std::shared_ptr<::DataFlow::ObjectBase>>;

enum class FlowDir : unsigned char
{
    fdRecv = 0,
    fdSend = 1
};

using DTypeList = ::std::vector<::DataFlow::NDType>;

using ShapeList = ::std::vector<::DataFlow::Shape>;

using TensorInfoList = ::std::vector<::std::shared_ptr<::DataFlow::TensorInfo>>;

class ExceptionClosed : public ::Ice::UserExceptionHelper<ExceptionClosed, ::Ice::UserException>
{
public:

    virtual ~ExceptionClosed();

    ExceptionClosed(const ExceptionClosed&) = default;

    ExceptionClosed() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

static ExceptionClosed _iceS_ExceptionClosed_init;

constexpr int rpcPortDataServer = 50000;

}

namespace DataFlow
{

class IOStream : public virtual ::Ice::Object
{
public:

    using ProxyType = IOStreamPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();
};

class DataServer : public virtual ::Ice::Object
{
public:

    using ProxyType = DataServerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void init(::std::shared_ptr<::DataFlow::InitServerParams>, const ::Ice::Current&) = 0;
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::DataFlow::DSStatus> getStatus(const ::Ice::Current&) = 0;
    bool _iceD_getStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::DataFlow::BatchDataProcessorStatus> getBatchDataProcessorStatus(::std::string, int, const ::Ice::Current&) = 0;
    bool _iceD_getBatchDataProcessorStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void putData(::std::shared_ptr<::DataFlow::IODataPut>, const ::Ice::Current&) = 0;
    bool _iceD_putData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::DataFlow::IODataGet> getData(::std::string, int, const ::Ice::Current&) = 0;
    bool _iceD_getData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class BatchDataProcessor : public virtual ::Ice::Object
{
public:

    using ProxyType = BatchDataProcessorPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void onEvent(::DataFlow::EventParamMap, const ::Ice::Current&) = 0;
    bool _iceD_onEvent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

}

namespace DataFlow
{

class NDArray : public ::Ice::ValueHelper<NDArray, Ice::Value>
{
public:

    virtual ~NDArray();

    NDArray() = default;

    NDArray(const NDArray&) = default;
    NDArray(NDArray&&) = default;
    NDArray& operator=(const NDArray&) = default;
    NDArray& operator=(NDArray&&) = default;

    NDArray(::DataFlow::NDType iceP_dtype, const ::DataFlow::Shape& iceP_shape, const ::DataFlow::ByteSeq& iceP_buffer) :
        dtype(iceP_dtype),
        shape(::std::move(iceP_shape)),
        buffer(::std::move(iceP_buffer))
    {
    }

    std::tuple<const ::DataFlow::NDType&, const ::DataFlow::Shape&, const ::DataFlow::ByteSeq&> ice_tuple() const
    {
        return std::tie(dtype, shape, buffer);
    }

    static const ::std::string& ice_staticId();

    ::DataFlow::NDType dtype;
    ::DataFlow::Shape shape;
    ::DataFlow::ByteSeq buffer;
};

static NDArray _iceS_NDArray_init;

class IOData : public ::Ice::ValueHelper<IOData, Ice::Value>
{
public:

    virtual ~IOData();

    IOData() = default;

    IOData(const IOData&) = default;
    IOData(IOData&&) = default;
    IOData& operator=(const IOData&) = default;
    IOData& operator=(IOData&&) = default;

    explicit IOData(const ::DataFlow::NDArrayMap& iceP_datas) :
        datas(::std::move(iceP_datas))
    {
    }

    std::tuple<const ::DataFlow::NDArrayMap&> ice_tuple() const
    {
        return std::tie(datas);
    }

    static const ::std::string& ice_staticId();

    ::DataFlow::NDArrayMap datas;
};

class IODataPut : public ::Ice::ValueHelper<IODataPut, ::DataFlow::IOData>
{
public:

    virtual ~IODataPut();

    IODataPut() = default;

    IODataPut(const IODataPut&) = default;
    IODataPut(IODataPut&&) = default;
    IODataPut& operator=(const IODataPut&) = default;
    IODataPut& operator=(IODataPut&&) = default;

    IODataPut(const ::DataFlow::NDArrayMap& iceP_datas, const ::std::string& iceP_name, bool iceP_isTrain, int iceP_processorIdx) :
        Ice::ValueHelper<::DataFlow::IODataPut, ::DataFlow::IOData>(::std::move(iceP_datas)),
        name(::std::move(iceP_name)),
        isTrain(iceP_isTrain),
        processorIdx(iceP_processorIdx)
    {
    }

    std::tuple<const ::DataFlow::NDArrayMap&, const ::std::string&, const bool&, const int&> ice_tuple() const
    {
        return std::tie(datas, name, isTrain, processorIdx);
    }

    static const ::std::string& ice_staticId();

    ::std::string name;
    bool isTrain = true;
    int processorIdx;
};

class IODataGet : public ::Ice::ValueHelper<IODataGet, ::DataFlow::IOData>
{
public:

    virtual ~IODataGet();

    IODataGet() = default;

    IODataGet(const IODataGet&) = default;
    IODataGet(IODataGet&&) = default;
    IODataGet& operator=(const IODataGet&) = default;
    IODataGet& operator=(IODataGet&&) = default;

    IODataGet(const ::DataFlow::NDArrayMap& iceP_datas, int iceP_epoch) :
        Ice::ValueHelper<::DataFlow::IODataGet, ::DataFlow::IOData>(::std::move(iceP_datas)),
        epoch(iceP_epoch)
    {
    }

    std::tuple<const ::DataFlow::NDArrayMap&, const int&> ice_tuple() const
    {
        return std::tie(datas, epoch);
    }

    static const ::std::string& ice_staticId();

    int epoch;
};

class IOStreamParam : public ::Ice::ValueHelper<IOStreamParam, Ice::Value>
{
public:

    virtual ~IOStreamParam();

    IOStreamParam() = default;

    IOStreamParam(const IOStreamParam&) = default;
    IOStreamParam(IOStreamParam&&) = default;
    IOStreamParam& operator=(const IOStreamParam&) = default;
    IOStreamParam& operator=(IOStreamParam&&) = default;

    explicit IOStreamParam(const ::std::string& iceP_name) :
        name(::std::move(iceP_name))
    {
    }

    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    static const ::std::string& ice_staticId();

    ::std::string name;
};

class ObjectBase : public ::Ice::ValueHelper<ObjectBase, Ice::Value>
{
public:

    virtual ~ObjectBase();

    ObjectBase() = default;

    ObjectBase(const ObjectBase&) = default;
    ObjectBase(ObjectBase&&) = default;
    ObjectBase& operator=(const ObjectBase&) = default;
    ObjectBase& operator=(ObjectBase&&) = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class InitServerParams : public ::Ice::ValueHelper<InitServerParams, Ice::Value>
{
public:

    virtual ~InitServerParams();

    InitServerParams() = default;

    InitServerParams(const InitServerParams&) = default;
    InitServerParams(InitServerParams&&) = default;
    InitServerParams& operator=(const InitServerParams&) = default;
    InitServerParams& operator=(InitServerParams&&) = default;

    explicit InitServerParams(int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(epoch);
    }

    static const ::std::string& ice_staticId();

    int epoch = 0;
};

class DSStatus : public ::Ice::ValueHelper<DSStatus, Ice::Value>
{
public:

    virtual ~DSStatus();

    DSStatus() = default;

    DSStatus(const DSStatus&) = default;
    DSStatus(DSStatus&&) = default;
    DSStatus& operator=(const DSStatus&) = default;
    DSStatus& operator=(DSStatus&&) = default;

    explicit DSStatus(int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(epoch);
    }

    static const ::std::string& ice_staticId();

    int epoch = 0;
};

class TensorInfo : public ::Ice::ValueHelper<TensorInfo, Ice::Value>
{
public:

    virtual ~TensorInfo();

    TensorInfo() = default;

    TensorInfo(const TensorInfo&) = default;
    TensorInfo(TensorInfo&&) = default;
    TensorInfo& operator=(const TensorInfo&) = default;
    TensorInfo& operator=(TensorInfo&&) = default;

    TensorInfo(const ::std::string& iceP_name, ::DataFlow::NDType iceP_dtype, const ::DataFlow::Shape& iceP_shape) :
        name(::std::move(iceP_name)),
        dtype(iceP_dtype),
        shape(::std::move(iceP_shape))
    {
    }

    std::tuple<const ::std::string&, const ::DataFlow::NDType&, const ::DataFlow::Shape&> ice_tuple() const
    {
        return std::tie(name, dtype, shape);
    }

    static const ::std::string& ice_staticId();

    ::std::string name;
    ::DataFlow::NDType dtype;
    ::DataFlow::Shape shape;
};

class TensorInfos : public ::Ice::ValueHelper<TensorInfos, Ice::Value>
{
public:

    virtual ~TensorInfos();

    TensorInfos() = default;

    TensorInfos(const TensorInfos&) = default;
    TensorInfos(TensorInfos&&) = default;
    TensorInfos& operator=(const TensorInfos&) = default;
    TensorInfos& operator=(TensorInfos&&) = default;

    TensorInfos(const ::DataFlow::TensorInfoList& iceP_train, const ::DataFlow::TensorInfoList& iceP_predict) :
        train(::std::move(iceP_train)),
        predict(::std::move(iceP_predict))
    {
    }

    std::tuple<const ::DataFlow::TensorInfoList&, const ::DataFlow::TensorInfoList&> ice_tuple() const
    {
        return std::tie(train, predict);
    }

    static const ::std::string& ice_staticId();

    ::DataFlow::TensorInfoList train;
    ::DataFlow::TensorInfoList predict;
};

class PacketStatistic : public ::Ice::ValueHelper<PacketStatistic, Ice::Value>
{
public:

    virtual ~PacketStatistic();

    PacketStatistic() = default;

    PacketStatistic(const PacketStatistic&) = default;
    PacketStatistic(PacketStatistic&&) = default;
    PacketStatistic& operator=(const PacketStatistic&) = default;
    PacketStatistic& operator=(PacketStatistic&&) = default;

    PacketStatistic(long long int iceP_packetRecvCount, long long int iceP_timeLastPacketRecved, long long int iceP_packetRecvProcessedCount, long long int iceP_packetSendCount, long long int iceP_packetSendInQueueCount) :
        packetRecvCount(iceP_packetRecvCount),
        timeLastPacketRecved(iceP_timeLastPacketRecved),
        packetRecvProcessedCount(iceP_packetRecvProcessedCount),
        packetSendCount(iceP_packetSendCount),
        packetSendInQueueCount(iceP_packetSendInQueueCount)
    {
    }

    std::tuple<const long long int&, const long long int&, const long long int&, const long long int&, const long long int&> ice_tuple() const
    {
        return std::tie(packetRecvCount, timeLastPacketRecved, packetRecvProcessedCount, packetSendCount, packetSendInQueueCount);
    }

    static const ::std::string& ice_staticId();

    long long int packetRecvCount = 0LL;
    long long int timeLastPacketRecved = 0LL;
    long long int packetRecvProcessedCount = 0LL;
    long long int packetSendCount = 0LL;
    long long int packetSendInQueueCount = 0LL;
};

class BatchDataProcessorStatus : public ::Ice::ValueHelper<BatchDataProcessorStatus, Ice::Value>
{
public:

    virtual ~BatchDataProcessorStatus();

    BatchDataProcessorStatus() = default;

    BatchDataProcessorStatus(const BatchDataProcessorStatus&) = default;
    BatchDataProcessorStatus(BatchDataProcessorStatus&&) = default;
    BatchDataProcessorStatus& operator=(const BatchDataProcessorStatus&) = default;
    BatchDataProcessorStatus& operator=(BatchDataProcessorStatus&&) = default;

    BatchDataProcessorStatus(int iceP_batchIdxStart, int iceP_batchSize, const ::std::shared_ptr<::DataFlow::PacketStatistic>& iceP_packetTrain, const ::std::shared_ptr<::DataFlow::PacketStatistic>& iceP_packetPredict, const ::std::shared_ptr<::DataFlow::TensorInfos>& iceP_tensorInfos) :
        batchIdxStart(iceP_batchIdxStart),
        batchSize(iceP_batchSize),
        packetTrain(::std::move(iceP_packetTrain)),
        packetPredict(::std::move(iceP_packetPredict)),
        tensorInfos(::std::move(iceP_tensorInfos))
    {
    }

    std::tuple<const int&, const int&, const ::std::shared_ptr<::DataFlow::PacketStatistic>&, const ::std::shared_ptr<::DataFlow::PacketStatistic>&, const ::std::shared_ptr<::DataFlow::TensorInfos>&> ice_tuple() const
    {
        return std::tie(batchIdxStart, batchSize, packetTrain, packetPredict, tensorInfos);
    }

    static const ::std::string& ice_staticId();

    int batchIdxStart;
    int batchSize;
    ::std::shared_ptr<::DataFlow::PacketStatistic> packetTrain;
    ::std::shared_ptr<::DataFlow::PacketStatistic> packetPredict;
    ::std::shared_ptr<::DataFlow::TensorInfos> tensorInfos;
};

class EvtEpoch : public ::Ice::ValueHelper<EvtEpoch, ::DataFlow::ObjectBase>
{
public:

    virtual ~EvtEpoch();

    EvtEpoch() = default;

    EvtEpoch(const EvtEpoch&) = default;
    EvtEpoch(EvtEpoch&&) = default;
    EvtEpoch& operator=(const EvtEpoch&) = default;
    EvtEpoch& operator=(EvtEpoch&&) = default;

    explicit EvtEpoch(int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(epoch);
    }

    static const ::std::string& ice_staticId();

    int epoch;
};

}

namespace DataFlow
{

class IOStreamPrx : public virtual ::Ice::Proxy<IOStreamPrx, ::Ice::ObjectPrx>
{
public:

    static const ::std::string& ice_staticId();

protected:

    IOStreamPrx() = default;
    friend ::std::shared_ptr<IOStreamPrx> IceInternal::createProxy<IOStreamPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class DataServerPrx : public virtual ::Ice::Proxy<DataServerPrx, ::Ice::ObjectPrx>
{
public:

    void init(const ::std::shared_ptr<::DataFlow::InitServerParams>& iceP_params, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DataFlow::DataServerPrx::_iceI_init, iceP_params, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto initAsync(const ::std::shared_ptr<::DataFlow::InitServerParams>& iceP_params, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DataFlow::DataServerPrx::_iceI_init, iceP_params, context);
    }

    ::std::function<void()>
    initAsync(const ::std::shared_ptr<::DataFlow::InitServerParams>& iceP_params,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &DataFlow::DataServerPrx::_iceI_init, iceP_params, context);
    }

    void _iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::DataFlow::InitServerParams>&, const ::Ice::Context&);

    ::std::shared_ptr<::DataFlow::DSStatus> getStatus(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::DSStatus>>(true, this, &DataFlow::DataServerPrx::_iceI_getStatus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStatusAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::DataFlow::DSStatus>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::DSStatus>, P>(false, this, &DataFlow::DataServerPrx::_iceI_getStatus, context);
    }

    ::std::function<void()>
    getStatusAsync(::std::function<void(::std::shared_ptr<::DataFlow::DSStatus>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::DataFlow::DSStatus>>(response, ex, sent, this, &DataFlow::DataServerPrx::_iceI_getStatus, context);
    }

    void _iceI_getStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::DSStatus>>>&, const ::Ice::Context&);

    ::std::shared_ptr<::DataFlow::BatchDataProcessorStatus> getBatchDataProcessorStatus(const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>>(true, this, &DataFlow::DataServerPrx::_iceI_getBatchDataProcessorStatus, iceP_name, iceP_processorIdx, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getBatchDataProcessorStatusAsync(const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>, P>(false, this, &DataFlow::DataServerPrx::_iceI_getBatchDataProcessorStatus, iceP_name, iceP_processorIdx, context);
    }

    ::std::function<void()>
    getBatchDataProcessorStatusAsync(const ::std::string& iceP_name, int iceP_processorIdx,
                                     ::std::function<void(::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                     ::std::function<void(bool)> sent = nullptr,
                                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>>(response, ex, sent, this, &DataFlow::DataServerPrx::_iceI_getBatchDataProcessorStatus, iceP_name, iceP_processorIdx, context);
    }

    void _iceI_getBatchDataProcessorStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>>>&, const ::std::string&, int, const ::Ice::Context&);

    void putData(const ::std::shared_ptr<::DataFlow::IODataPut>& iceP_data, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DataFlow::DataServerPrx::_iceI_putData, iceP_data, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto putDataAsync(const ::std::shared_ptr<::DataFlow::IODataPut>& iceP_data, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DataFlow::DataServerPrx::_iceI_putData, iceP_data, context);
    }

    ::std::function<void()>
    putDataAsync(const ::std::shared_ptr<::DataFlow::IODataPut>& iceP_data,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &DataFlow::DataServerPrx::_iceI_putData, iceP_data, context);
    }

    void _iceI_putData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::DataFlow::IODataPut>&, const ::Ice::Context&);

    ::std::shared_ptr<::DataFlow::IODataGet> getData(const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::IODataGet>>(true, this, &DataFlow::DataServerPrx::_iceI_getData, iceP_name, iceP_processorIdx, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDataAsync(const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::DataFlow::IODataGet>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::DataFlow::IODataGet>, P>(false, this, &DataFlow::DataServerPrx::_iceI_getData, iceP_name, iceP_processorIdx, context);
    }

    ::std::function<void()>
    getDataAsync(const ::std::string& iceP_name, int iceP_processorIdx,
                 ::std::function<void(::std::shared_ptr<::DataFlow::IODataGet>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::DataFlow::IODataGet>>(response, ex, sent, this, &DataFlow::DataServerPrx::_iceI_getData, iceP_name, iceP_processorIdx, context);
    }

    void _iceI_getData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::IODataGet>>>&, const ::std::string&, int, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    DataServerPrx() = default;
    friend ::std::shared_ptr<DataServerPrx> IceInternal::createProxy<DataServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class BatchDataProcessorPrx : public virtual ::Ice::Proxy<BatchDataProcessorPrx, ::Ice::ObjectPrx>
{
public:

    void onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DataFlow::BatchDataProcessorPrx::_iceI_onEvent, iceP_params, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onEventAsync(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DataFlow::BatchDataProcessorPrx::_iceI_onEvent, iceP_params, context);
    }

    ::std::function<void()>
    onEventAsync(const ::DataFlow::EventParamMap& iceP_params,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &DataFlow::BatchDataProcessorPrx::_iceI_onEvent, iceP_params, context);
    }

    void _iceI_onEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::DataFlow::EventParamMap&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    BatchDataProcessorPrx() = default;
    friend ::std::shared_ptr<BatchDataProcessorPrx> IceInternal::createProxy<BatchDataProcessorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

template<>
struct StreamableTraits< ::DataFlow::NDType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::DataFlow::NDArray, S>
{
    static void read(S* istr, ::DataFlow::NDArray& v)
    {
        istr->readAll(v.dtype, v.shape, v.buffer);
    }
};

template<typename S>
struct StreamReader<::DataFlow::IOData, S>
{
    static void read(S* istr, ::DataFlow::IOData& v)
    {
        istr->readAll(v.datas);
    }
};

template<typename S>
struct StreamWriter<::DataFlow::IODataPut, S>
{
    static void write(S* ostr, const ::DataFlow::IODataPut& v)
    {
        ostr->writeAll(v.name, v.isTrain, v.processorIdx);
    }
};

template<typename S>
struct StreamReader<::DataFlow::IODataPut, S>
{
    static void read(S* istr, ::DataFlow::IODataPut& v)
    {
        istr->readAll(v.name, v.isTrain, v.processorIdx);
    }
};

template<typename S>
struct StreamWriter<::DataFlow::IODataGet, S>
{
    static void write(S* ostr, const ::DataFlow::IODataGet& v)
    {
        ostr->writeAll(v.epoch);
    }
};

template<typename S>
struct StreamReader<::DataFlow::IODataGet, S>
{
    static void read(S* istr, ::DataFlow::IODataGet& v)
    {
        istr->readAll(v.epoch);
    }
};

template<typename S>
struct StreamReader<::DataFlow::IOStreamParam, S>
{
    static void read(S* istr, ::DataFlow::IOStreamParam& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::DataFlow::InitServerParams, S>
{
    static void read(S* istr, ::DataFlow::InitServerParams& v)
    {
        istr->readAll(v.epoch);
    }
};

template<>
struct StreamableTraits< ::DataFlow::FlowDir>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::DataFlow::DSStatus, S>
{
    static void read(S* istr, ::DataFlow::DSStatus& v)
    {
        istr->readAll(v.epoch);
    }
};

template<typename S>
struct StreamReader<::DataFlow::TensorInfo, S>
{
    static void read(S* istr, ::DataFlow::TensorInfo& v)
    {
        istr->readAll(v.name, v.dtype, v.shape);
    }
};

template<typename S>
struct StreamReader<::DataFlow::TensorInfos, S>
{
    static void read(S* istr, ::DataFlow::TensorInfos& v)
    {
        istr->readAll(v.train, v.predict);
    }
};

template<typename S>
struct StreamReader<::DataFlow::PacketStatistic, S>
{
    static void read(S* istr, ::DataFlow::PacketStatistic& v)
    {
        istr->readAll(v.packetRecvCount, v.timeLastPacketRecved, v.packetRecvProcessedCount, v.packetSendCount, v.packetSendInQueueCount);
    }
};

template<typename S>
struct StreamReader<::DataFlow::BatchDataProcessorStatus, S>
{
    static void read(S* istr, ::DataFlow::BatchDataProcessorStatus& v)
    {
        istr->readAll(v.batchIdxStart, v.batchSize, v.packetTrain, v.packetPredict, v.tensorInfos);
    }
};

template<typename S>
struct StreamReader<::DataFlow::EvtEpoch, S>
{
    static void read(S* istr, ::DataFlow::EvtEpoch& v)
    {
        istr->readAll(v.epoch);
    }
};

}

namespace DataFlow
{

using NDArrayPtr = ::std::shared_ptr<NDArray>;

using IODataPtr = ::std::shared_ptr<IOData>;

using IODataPutPtr = ::std::shared_ptr<IODataPut>;

using IODataGetPtr = ::std::shared_ptr<IODataGet>;

using IOStreamParamPtr = ::std::shared_ptr<IOStreamParam>;

using IOStreamPtr = ::std::shared_ptr<IOStream>;
using IOStreamPrxPtr = ::std::shared_ptr<IOStreamPrx>;

using ObjectBasePtr = ::std::shared_ptr<ObjectBase>;

using InitServerParamsPtr = ::std::shared_ptr<InitServerParams>;

using DSStatusPtr = ::std::shared_ptr<DSStatus>;

using TensorInfoPtr = ::std::shared_ptr<TensorInfo>;

using TensorInfosPtr = ::std::shared_ptr<TensorInfos>;

using PacketStatisticPtr = ::std::shared_ptr<PacketStatistic>;

using BatchDataProcessorStatusPtr = ::std::shared_ptr<BatchDataProcessorStatus>;

using DataServerPtr = ::std::shared_ptr<DataServer>;
using DataServerPrxPtr = ::std::shared_ptr<DataServerPrx>;

using EvtEpochPtr = ::std::shared_ptr<EvtEpoch>;

using BatchDataProcessorPtr = ::std::shared_ptr<BatchDataProcessor>;
using BatchDataProcessorPrxPtr = ::std::shared_ptr<BatchDataProcessorPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace DataFlow
{

class NDArray;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::NDArray>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::NDArray*);

class IOData;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOData>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::IOData*);

class IODataPut;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataPut>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::IODataPut*);

class IODataGet;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataGet>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::IODataGet*);

class IOStreamParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStreamParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::IOStreamParam*);

class IOStream;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStream>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::IOStream*);

class ObjectBase;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::ObjectBase>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::ObjectBase*);

class InitServerParams;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::InitServerParams>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::InitServerParams*);

class DSStatus;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DSStatus>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::DSStatus*);

class TensorInfo;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::TensorInfo>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::TensorInfo*);

class TensorInfos;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::TensorInfos>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::TensorInfos*);

class PacketStatistic;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::PacketStatistic>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::PacketStatistic*);

class BatchDataProcessorStatus;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessorStatus>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::BatchDataProcessorStatus*);

class DataServer;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DataServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::DataServer*);

class EvtEpoch;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::EvtEpoch>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::EvtEpoch*);

class BatchDataProcessor;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessor>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataFlow::BatchDataProcessor*);

}

}

namespace DataFlow
{

class NDArray;
::Ice::Object* upCast(::DataFlow::NDArray*);
typedef ::IceInternal::Handle< ::DataFlow::NDArray> NDArrayPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::NDArray> NDArrayPrx;
typedef NDArrayPrx NDArrayPrxPtr;
void _icePatchObjectPtr(NDArrayPtr&, const ::Ice::ObjectPtr&);

class IOData;
::Ice::Object* upCast(::DataFlow::IOData*);
typedef ::IceInternal::Handle< ::DataFlow::IOData> IODataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOData> IODataPrx;
typedef IODataPrx IODataPrxPtr;
void _icePatchObjectPtr(IODataPtr&, const ::Ice::ObjectPtr&);

class IODataPut;
::Ice::Object* upCast(::DataFlow::IODataPut*);
typedef ::IceInternal::Handle< ::DataFlow::IODataPut> IODataPutPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataPut> IODataPutPrx;
typedef IODataPutPrx IODataPutPrxPtr;
void _icePatchObjectPtr(IODataPutPtr&, const ::Ice::ObjectPtr&);

class IODataGet;
::Ice::Object* upCast(::DataFlow::IODataGet*);
typedef ::IceInternal::Handle< ::DataFlow::IODataGet> IODataGetPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataGet> IODataGetPrx;
typedef IODataGetPrx IODataGetPrxPtr;
void _icePatchObjectPtr(IODataGetPtr&, const ::Ice::ObjectPtr&);

class IOStreamParam;
::Ice::Object* upCast(::DataFlow::IOStreamParam*);
typedef ::IceInternal::Handle< ::DataFlow::IOStreamParam> IOStreamParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStreamParam> IOStreamParamPrx;
typedef IOStreamParamPrx IOStreamParamPrxPtr;
void _icePatchObjectPtr(IOStreamParamPtr&, const ::Ice::ObjectPtr&);

class IOStream;
::Ice::Object* upCast(::DataFlow::IOStream*);
typedef ::IceInternal::Handle< ::DataFlow::IOStream> IOStreamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStream> IOStreamPrx;
typedef IOStreamPrx IOStreamPrxPtr;
void _icePatchObjectPtr(IOStreamPtr&, const ::Ice::ObjectPtr&);

class ObjectBase;
::Ice::Object* upCast(::DataFlow::ObjectBase*);
typedef ::IceInternal::Handle< ::DataFlow::ObjectBase> ObjectBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::ObjectBase> ObjectBasePrx;
typedef ObjectBasePrx ObjectBasePrxPtr;
void _icePatchObjectPtr(ObjectBasePtr&, const ::Ice::ObjectPtr&);

class InitServerParams;
::Ice::Object* upCast(::DataFlow::InitServerParams*);
typedef ::IceInternal::Handle< ::DataFlow::InitServerParams> InitServerParamsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::InitServerParams> InitServerParamsPrx;
typedef InitServerParamsPrx InitServerParamsPrxPtr;
void _icePatchObjectPtr(InitServerParamsPtr&, const ::Ice::ObjectPtr&);

class DSStatus;
::Ice::Object* upCast(::DataFlow::DSStatus*);
typedef ::IceInternal::Handle< ::DataFlow::DSStatus> DSStatusPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DSStatus> DSStatusPrx;
typedef DSStatusPrx DSStatusPrxPtr;
void _icePatchObjectPtr(DSStatusPtr&, const ::Ice::ObjectPtr&);

class TensorInfo;
::Ice::Object* upCast(::DataFlow::TensorInfo*);
typedef ::IceInternal::Handle< ::DataFlow::TensorInfo> TensorInfoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::TensorInfo> TensorInfoPrx;
typedef TensorInfoPrx TensorInfoPrxPtr;
void _icePatchObjectPtr(TensorInfoPtr&, const ::Ice::ObjectPtr&);

class TensorInfos;
::Ice::Object* upCast(::DataFlow::TensorInfos*);
typedef ::IceInternal::Handle< ::DataFlow::TensorInfos> TensorInfosPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::TensorInfos> TensorInfosPrx;
typedef TensorInfosPrx TensorInfosPrxPtr;
void _icePatchObjectPtr(TensorInfosPtr&, const ::Ice::ObjectPtr&);

class PacketStatistic;
::Ice::Object* upCast(::DataFlow::PacketStatistic*);
typedef ::IceInternal::Handle< ::DataFlow::PacketStatistic> PacketStatisticPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::PacketStatistic> PacketStatisticPrx;
typedef PacketStatisticPrx PacketStatisticPrxPtr;
void _icePatchObjectPtr(PacketStatisticPtr&, const ::Ice::ObjectPtr&);

class BatchDataProcessorStatus;
::Ice::Object* upCast(::DataFlow::BatchDataProcessorStatus*);
typedef ::IceInternal::Handle< ::DataFlow::BatchDataProcessorStatus> BatchDataProcessorStatusPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessorStatus> BatchDataProcessorStatusPrx;
typedef BatchDataProcessorStatusPrx BatchDataProcessorStatusPrxPtr;
void _icePatchObjectPtr(BatchDataProcessorStatusPtr&, const ::Ice::ObjectPtr&);

class DataServer;
::Ice::Object* upCast(::DataFlow::DataServer*);
typedef ::IceInternal::Handle< ::DataFlow::DataServer> DataServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DataServer> DataServerPrx;
typedef DataServerPrx DataServerPrxPtr;
void _icePatchObjectPtr(DataServerPtr&, const ::Ice::ObjectPtr&);

class EvtEpoch;
::Ice::Object* upCast(::DataFlow::EvtEpoch*);
typedef ::IceInternal::Handle< ::DataFlow::EvtEpoch> EvtEpochPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::EvtEpoch> EvtEpochPrx;
typedef EvtEpochPrx EvtEpochPrxPtr;
void _icePatchObjectPtr(EvtEpochPtr&, const ::Ice::ObjectPtr&);

class BatchDataProcessor;
::Ice::Object* upCast(::DataFlow::BatchDataProcessor*);
typedef ::IceInternal::Handle< ::DataFlow::BatchDataProcessor> BatchDataProcessorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessor> BatchDataProcessorPrx;
typedef BatchDataProcessorPrx BatchDataProcessorPrxPtr;
void _icePatchObjectPtr(BatchDataProcessorPtr&, const ::Ice::ObjectPtr&);

}

namespace DataFlow
{

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector< ::Ice::Int> Shape;

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::std::string> StringSeq;

enum NDType
{
    ndtFloat32 = 0,
    ndtUint8 = 1,
    ndtInt32 = 2,
    ndtInt64 = 3,
    ndtUnknown = 4
};

typedef ::std::vector< ::DataFlow::NDArrayPtr> NDArrayList;

typedef ::std::map< ::std::string, ::DataFlow::NDArrayPtr> NDArrayMap;

typedef ::std::vector< ::DataFlow::NDArrayPtr> TensorList;

typedef ::std::map< ::std::string, ::DataFlow::NDArrayPtr> TensorMap;

typedef ::std::map< ::std::string, ::DataFlow::ObjectBasePtr> EventParamMap;

enum FlowDir
{
    fdRecv = 0,
    fdSend = 1
};

typedef ::std::vector< ::DataFlow::NDType> DTypeList;

typedef ::std::vector< ::DataFlow::Shape> ShapeList;

typedef ::std::vector< ::DataFlow::TensorInfoPtr> TensorInfoList;

class ExceptionClosed : public ::Ice::UserException
{
public:

    ExceptionClosed() {}
    virtual ~ExceptionClosed() throw();

    virtual ::std::string ice_id() const;
    virtual ExceptionClosed* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

static ExceptionClosed _iceS_ExceptionClosed_init;

const ::Ice::Int rpcPortDataServer = 50000;

}

namespace DataFlow
{

class Callback_DataServer_init_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataServer_init_Base> Callback_DataServer_initPtr;

class Callback_DataServer_getStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataServer_getStatus_Base> Callback_DataServer_getStatusPtr;

class Callback_DataServer_getBatchDataProcessorStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataServer_getBatchDataProcessorStatus_Base> Callback_DataServer_getBatchDataProcessorStatusPtr;

class Callback_DataServer_putData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataServer_putData_Base> Callback_DataServer_putDataPtr;

class Callback_DataServer_getData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataServer_getData_Base> Callback_DataServer_getDataPtr;

class Callback_BatchDataProcessor_onEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BatchDataProcessor_onEvent_Base> Callback_BatchDataProcessor_onEventPtr;

}

namespace IceProxy
{

namespace DataFlow
{

class NDArray : public virtual ::Ice::Proxy<NDArray, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class IOData : public virtual ::Ice::Proxy<IOData, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class IODataPut : public virtual ::Ice::Proxy<IODataPut, ::IceProxy::DataFlow::IOData>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class IODataGet : public virtual ::Ice::Proxy<IODataGet, ::IceProxy::DataFlow::IOData>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class IOStreamParam : public virtual ::Ice::Proxy<IOStreamParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class IOStream : public virtual ::Ice::Proxy<IOStream, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class ObjectBase : public virtual ::Ice::Proxy<ObjectBase, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class InitServerParams : public virtual ::Ice::Proxy<InitServerParams, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class DSStatus : public virtual ::Ice::Proxy<DSStatus, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class TensorInfo : public virtual ::Ice::Proxy<TensorInfo, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class TensorInfos : public virtual ::Ice::Proxy<TensorInfos, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class PacketStatistic : public virtual ::Ice::Proxy<PacketStatistic, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class BatchDataProcessorStatus : public virtual ::Ice::Proxy<BatchDataProcessorStatus, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class DataServer : public virtual ::Ice::Proxy<DataServer, ::IceProxy::Ice::Object>
{
public:

    void init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_init(_iceI_begin_init(iceP_params, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_init(iceP_params, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_params, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_params, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::DataFlow::Callback_DataServer_initPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_params, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::Context& context, const ::DataFlow::Callback_DataServer_initPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_params, context, del, cookie);
    }

    void end_init(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_init(const ::DataFlow::InitServerParamsPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::DataFlow::DSStatusPtr getStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStatus(_iceI_begin_getStatus(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStatus(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStatus(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatus(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatus(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatus(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatus(const ::DataFlow::Callback_DataServer_getStatusPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatus(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatus(const ::Ice::Context& context, const ::DataFlow::Callback_DataServer_getStatusPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatus(context, del, cookie);
    }

    ::DataFlow::DSStatusPtr end_getStatus(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStatus(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::DataFlow::BatchDataProcessorStatusPtr getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getBatchDataProcessorStatus(_iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::DataFlow::Callback_DataServer_getBatchDataProcessorStatusPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::DataFlow::Callback_DataServer_getBatchDataProcessorStatusPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, context, del, cookie);
    }

    ::DataFlow::BatchDataProcessorStatusPtr end_getBatchDataProcessorStatus(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getBatchDataProcessorStatus(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_putData(_iceI_begin_putData(iceP_data, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_putData(iceP_data, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_putData(iceP_data, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_putData(iceP_data, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::DataFlow::Callback_DataServer_putDataPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_putData(iceP_data, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::Context& context, const ::DataFlow::Callback_DataServer_putDataPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_putData(iceP_data, context, del, cookie);
    }

    void end_putData(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_putData(const ::DataFlow::IODataPutPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::DataFlow::IODataGetPtr getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getData(_iceI_begin_getData(iceP_name, iceP_processorIdx, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getData(iceP_name, iceP_processorIdx, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getData(iceP_name, iceP_processorIdx, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getData(iceP_name, iceP_processorIdx, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::DataFlow::Callback_DataServer_getDataPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getData(iceP_name, iceP_processorIdx, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::DataFlow::Callback_DataServer_getDataPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getData(iceP_name, iceP_processorIdx, context, del, cookie);
    }

    ::DataFlow::IODataGetPtr end_getData(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getData(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class EvtEpoch : public virtual ::Ice::Proxy<EvtEpoch, ::IceProxy::DataFlow::ObjectBase>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class BatchDataProcessor : public virtual ::Ice::Proxy<BatchDataProcessor, ::IceProxy::Ice::Object>
{
public:

    void onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onEvent(_iceI_begin_onEvent(iceP_params, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onEvent(iceP_params, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_params, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_params, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::DataFlow::Callback_BatchDataProcessor_onEventPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_params, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context, const ::DataFlow::Callback_BatchDataProcessor_onEventPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_params, context, del, cookie);
    }

    void end_onEvent(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onEvent(const ::DataFlow::EventParamMap&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace DataFlow
{

class NDArray : public virtual ::Ice::Object
{
public:

    typedef NDArrayPrx ProxyType;
    typedef NDArrayPtr PointerType;

    virtual ~NDArray();

    NDArray()
    {
    }

    NDArray(::DataFlow::NDType iceP_dtype, const ::DataFlow::Shape& iceP_shape, const ::DataFlow::ByteSeq& iceP_buffer) :
        dtype(iceP_dtype),
        shape(iceP_shape),
        buffer(iceP_buffer)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::DataFlow::NDType dtype;
    ::DataFlow::Shape shape;
    ::DataFlow::ByteSeq buffer;
};
static ::Ice::ValueFactoryPtr _iceS_NDArray_init = ::DataFlow::NDArray::ice_factory();

inline bool operator==(const NDArray& lhs, const NDArray& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const NDArray& lhs, const NDArray& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class IOData : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef IODataPrx ProxyType;
    typedef IODataPtr PointerType;

    virtual ~IOData();

    IOData()
    {
    }

    explicit IOData(const ::DataFlow::NDArrayMap& iceP_datas) :
        datas(iceP_datas)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::DataFlow::NDArrayMap datas;
};
static ::Ice::ValueFactoryPtr _iceS_IOData_init = ::DataFlow::IOData::ice_factory();

inline bool operator==(const IOData& lhs, const IOData& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IOData& lhs, const IOData& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class IODataPut : public ::DataFlow::IOData
{
public:

    typedef IODataPutPrx ProxyType;
    typedef IODataPutPtr PointerType;

    virtual ~IODataPut();

    IODataPut() :
        isTrain(true)
    {
    }

    IODataPut(const ::DataFlow::NDArrayMap& iceP_datas, const ::std::string& iceP_name, bool iceP_isTrain, ::Ice::Int iceP_processorIdx) :
        ::DataFlow::IOData(iceP_datas),
        name(iceP_name),
        isTrain(iceP_isTrain),
        processorIdx(iceP_processorIdx)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::std::string name;
    bool isTrain;
    ::Ice::Int processorIdx;
};
static ::Ice::ValueFactoryPtr _iceS_IODataPut_init = ::DataFlow::IODataPut::ice_factory();

inline bool operator==(const IODataPut& lhs, const IODataPut& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IODataPut& lhs, const IODataPut& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class IODataGet : public ::DataFlow::IOData
{
public:

    typedef IODataGetPrx ProxyType;
    typedef IODataGetPtr PointerType;

    virtual ~IODataGet();

    IODataGet()
    {
    }

    IODataGet(const ::DataFlow::NDArrayMap& iceP_datas, ::Ice::Int iceP_epoch) :
        ::DataFlow::IOData(iceP_datas),
        epoch(iceP_epoch)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int epoch;
};
static ::Ice::ValueFactoryPtr _iceS_IODataGet_init = ::DataFlow::IODataGet::ice_factory();

inline bool operator==(const IODataGet& lhs, const IODataGet& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IODataGet& lhs, const IODataGet& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class IOStreamParam : public virtual ::Ice::Object
{
public:

    typedef IOStreamParamPrx ProxyType;
    typedef IOStreamParamPtr PointerType;

    virtual ~IOStreamParam();

    IOStreamParam()
    {
    }

    explicit IOStreamParam(const ::std::string& iceP_name) :
        name(iceP_name)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::std::string name;
};
static ::Ice::ValueFactoryPtr _iceS_IOStreamParam_init = ::DataFlow::IOStreamParam::ice_factory();

inline bool operator==(const IOStreamParam& lhs, const IOStreamParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IOStreamParam& lhs, const IOStreamParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class IOStream : public virtual ::Ice::Object
{
public:

    typedef IOStreamPrx ProxyType;
    typedef IOStreamPtr PointerType;

    virtual ~IOStream();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const IOStream& lhs, const IOStream& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IOStream& lhs, const IOStream& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class ObjectBase : public virtual ::Ice::Object
{
public:

    typedef ObjectBasePrx ProxyType;
    typedef ObjectBasePtr PointerType;

    virtual ~ObjectBase();

    ObjectBase()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};
static ::Ice::ValueFactoryPtr _iceS_ObjectBase_init = ::DataFlow::ObjectBase::ice_factory();

inline bool operator==(const ObjectBase& lhs, const ObjectBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ObjectBase& lhs, const ObjectBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class InitServerParams : public virtual ::Ice::Object
{
public:

    typedef InitServerParamsPrx ProxyType;
    typedef InitServerParamsPtr PointerType;

    virtual ~InitServerParams();

    InitServerParams() :
        epoch(0)
    {
    }

    explicit InitServerParams(::Ice::Int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int epoch;
};
static ::Ice::ValueFactoryPtr _iceS_InitServerParams_init = ::DataFlow::InitServerParams::ice_factory();

inline bool operator==(const InitServerParams& lhs, const InitServerParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const InitServerParams& lhs, const InitServerParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class DSStatus : public virtual ::Ice::Object
{
public:

    typedef DSStatusPrx ProxyType;
    typedef DSStatusPtr PointerType;

    virtual ~DSStatus();

    DSStatus() :
        epoch(0)
    {
    }

    explicit DSStatus(::Ice::Int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int epoch;
};
static ::Ice::ValueFactoryPtr _iceS_DSStatus_init = ::DataFlow::DSStatus::ice_factory();

inline bool operator==(const DSStatus& lhs, const DSStatus& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const DSStatus& lhs, const DSStatus& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class TensorInfo : public virtual ::Ice::Object
{
public:

    typedef TensorInfoPrx ProxyType;
    typedef TensorInfoPtr PointerType;

    virtual ~TensorInfo();

    TensorInfo()
    {
    }

    TensorInfo(const ::std::string& iceP_name, ::DataFlow::NDType iceP_dtype, const ::DataFlow::Shape& iceP_shape) :
        name(iceP_name),
        dtype(iceP_dtype),
        shape(iceP_shape)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::std::string name;
    ::DataFlow::NDType dtype;
    ::DataFlow::Shape shape;
};
static ::Ice::ValueFactoryPtr _iceS_TensorInfo_init = ::DataFlow::TensorInfo::ice_factory();

inline bool operator==(const TensorInfo& lhs, const TensorInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TensorInfo& lhs, const TensorInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class TensorInfos : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef TensorInfosPrx ProxyType;
    typedef TensorInfosPtr PointerType;

    virtual ~TensorInfos();

    TensorInfos()
    {
    }

    TensorInfos(const ::DataFlow::TensorInfoList& iceP_train, const ::DataFlow::TensorInfoList& iceP_predict) :
        train(iceP_train),
        predict(iceP_predict)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::DataFlow::TensorInfoList train;
    ::DataFlow::TensorInfoList predict;
};
static ::Ice::ValueFactoryPtr _iceS_TensorInfos_init = ::DataFlow::TensorInfos::ice_factory();

inline bool operator==(const TensorInfos& lhs, const TensorInfos& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TensorInfos& lhs, const TensorInfos& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class PacketStatistic : public virtual ::Ice::Object
{
public:

    typedef PacketStatisticPrx ProxyType;
    typedef PacketStatisticPtr PointerType;

    virtual ~PacketStatistic();

    PacketStatistic() :
        packetRecvCount(ICE_INT64(0)),
        timeLastPacketRecved(ICE_INT64(0)),
        packetRecvProcessedCount(ICE_INT64(0)),
        packetSendCount(ICE_INT64(0)),
        packetSendInQueueCount(ICE_INT64(0))
    {
    }

    PacketStatistic(::Ice::Long iceP_packetRecvCount, ::Ice::Long iceP_timeLastPacketRecved, ::Ice::Long iceP_packetRecvProcessedCount, ::Ice::Long iceP_packetSendCount, ::Ice::Long iceP_packetSendInQueueCount) :
        packetRecvCount(iceP_packetRecvCount),
        timeLastPacketRecved(iceP_timeLastPacketRecved),
        packetRecvProcessedCount(iceP_packetRecvProcessedCount),
        packetSendCount(iceP_packetSendCount),
        packetSendInQueueCount(iceP_packetSendInQueueCount)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Long packetRecvCount;
    ::Ice::Long timeLastPacketRecved;
    ::Ice::Long packetRecvProcessedCount;
    ::Ice::Long packetSendCount;
    ::Ice::Long packetSendInQueueCount;
};
static ::Ice::ValueFactoryPtr _iceS_PacketStatistic_init = ::DataFlow::PacketStatistic::ice_factory();

inline bool operator==(const PacketStatistic& lhs, const PacketStatistic& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PacketStatistic& lhs, const PacketStatistic& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class BatchDataProcessorStatus : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef BatchDataProcessorStatusPrx ProxyType;
    typedef BatchDataProcessorStatusPtr PointerType;

    virtual ~BatchDataProcessorStatus();

    BatchDataProcessorStatus()
    {
    }

    BatchDataProcessorStatus(::Ice::Int iceP_batchIdxStart, ::Ice::Int iceP_batchSize, const ::DataFlow::PacketStatisticPtr& iceP_packetTrain, const ::DataFlow::PacketStatisticPtr& iceP_packetPredict, const ::DataFlow::TensorInfosPtr& iceP_tensorInfos) :
        batchIdxStart(iceP_batchIdxStart),
        batchSize(iceP_batchSize),
        packetTrain(iceP_packetTrain),
        packetPredict(iceP_packetPredict),
        tensorInfos(iceP_tensorInfos)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int batchIdxStart;
    ::Ice::Int batchSize;
    ::DataFlow::PacketStatisticPtr packetTrain;
    ::DataFlow::PacketStatisticPtr packetPredict;
    ::DataFlow::TensorInfosPtr tensorInfos;
};
static ::Ice::ValueFactoryPtr _iceS_BatchDataProcessorStatus_init = ::DataFlow::BatchDataProcessorStatus::ice_factory();

inline bool operator==(const BatchDataProcessorStatus& lhs, const BatchDataProcessorStatus& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BatchDataProcessorStatus& lhs, const BatchDataProcessorStatus& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class DataServer : public virtual ::Ice::Object
{
public:

    typedef DataServerPrx ProxyType;
    typedef DataServerPtr PointerType;

    virtual ~DataServer();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void init(const ::DataFlow::InitServerParamsPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::DataFlow::DSStatusPtr getStatus(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::DataFlow::BatchDataProcessorStatusPtr getBatchDataProcessorStatus(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getBatchDataProcessorStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void putData(const ::DataFlow::IODataPutPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_putData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::DataFlow::IODataGetPtr getData(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const DataServer& lhs, const DataServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const DataServer& lhs, const DataServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class EvtEpoch : public ::DataFlow::ObjectBase
{
public:

    typedef EvtEpochPrx ProxyType;
    typedef EvtEpochPtr PointerType;

    virtual ~EvtEpoch();

    EvtEpoch()
    {
    }

    explicit EvtEpoch(::Ice::Int iceP_epoch) :
        epoch(iceP_epoch)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int epoch;
};
static ::Ice::ValueFactoryPtr _iceS_EvtEpoch_init = ::DataFlow::EvtEpoch::ice_factory();

inline bool operator==(const EvtEpoch& lhs, const EvtEpoch& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EvtEpoch& lhs, const EvtEpoch& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class BatchDataProcessor : public virtual ::Ice::Object
{
public:

    typedef BatchDataProcessorPrx ProxyType;
    typedef BatchDataProcessorPtr PointerType;

    virtual ~BatchDataProcessor();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void onEvent(const ::DataFlow::EventParamMap&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_onEvent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const BatchDataProcessor& lhs, const BatchDataProcessor& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BatchDataProcessor& lhs, const BatchDataProcessor& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<>
struct StreamableTraits< ::DataFlow::NDType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::DataFlow::NDArray, S>
{
    static void write(S* ostr, const ::DataFlow::NDArray& v)
    {
        ostr->write(v.dtype);
        ostr->write(v.shape);
        ostr->write(v.buffer);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::NDArray, S>
{
    static void read(S* istr, ::DataFlow::NDArray& v)
    {
        istr->read(v.dtype);
        istr->read(v.shape);
        istr->read(v.buffer);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::IOData, S>
{
    static void write(S* ostr, const ::DataFlow::IOData& v)
    {
        ostr->write(v.datas);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::IOData, S>
{
    static void read(S* istr, ::DataFlow::IOData& v)
    {
        istr->read(v.datas);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::IODataPut, S>
{
    static void write(S* ostr, const ::DataFlow::IODataPut& v)
    {
        ostr->write(v.name);
        ostr->write(v.isTrain);
        ostr->write(v.processorIdx);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::IODataPut, S>
{
    static void read(S* istr, ::DataFlow::IODataPut& v)
    {
        istr->read(v.name);
        istr->read(v.isTrain);
        istr->read(v.processorIdx);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::IODataGet, S>
{
    static void write(S* ostr, const ::DataFlow::IODataGet& v)
    {
        ostr->write(v.epoch);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::IODataGet, S>
{
    static void read(S* istr, ::DataFlow::IODataGet& v)
    {
        istr->read(v.epoch);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::IOStreamParam, S>
{
    static void write(S* ostr, const ::DataFlow::IOStreamParam& v)
    {
        ostr->write(v.name);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::IOStreamParam, S>
{
    static void read(S* istr, ::DataFlow::IOStreamParam& v)
    {
        istr->read(v.name);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::InitServerParams, S>
{
    static void write(S* ostr, const ::DataFlow::InitServerParams& v)
    {
        ostr->write(v.epoch);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::InitServerParams, S>
{
    static void read(S* istr, ::DataFlow::InitServerParams& v)
    {
        istr->read(v.epoch);
    }
};

template<>
struct StreamableTraits< ::DataFlow::FlowDir>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::DataFlow::DSStatus, S>
{
    static void write(S* ostr, const ::DataFlow::DSStatus& v)
    {
        ostr->write(v.epoch);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::DSStatus, S>
{
    static void read(S* istr, ::DataFlow::DSStatus& v)
    {
        istr->read(v.epoch);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::TensorInfo, S>
{
    static void write(S* ostr, const ::DataFlow::TensorInfo& v)
    {
        ostr->write(v.name);
        ostr->write(v.dtype);
        ostr->write(v.shape);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::TensorInfo, S>
{
    static void read(S* istr, ::DataFlow::TensorInfo& v)
    {
        istr->read(v.name);
        istr->read(v.dtype);
        istr->read(v.shape);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::TensorInfos, S>
{
    static void write(S* ostr, const ::DataFlow::TensorInfos& v)
    {
        ostr->write(v.train);
        ostr->write(v.predict);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::TensorInfos, S>
{
    static void read(S* istr, ::DataFlow::TensorInfos& v)
    {
        istr->read(v.train);
        istr->read(v.predict);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::PacketStatistic, S>
{
    static void write(S* ostr, const ::DataFlow::PacketStatistic& v)
    {
        ostr->write(v.packetRecvCount);
        ostr->write(v.timeLastPacketRecved);
        ostr->write(v.packetRecvProcessedCount);
        ostr->write(v.packetSendCount);
        ostr->write(v.packetSendInQueueCount);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::PacketStatistic, S>
{
    static void read(S* istr, ::DataFlow::PacketStatistic& v)
    {
        istr->read(v.packetRecvCount);
        istr->read(v.timeLastPacketRecved);
        istr->read(v.packetRecvProcessedCount);
        istr->read(v.packetSendCount);
        istr->read(v.packetSendInQueueCount);
    }
};

template<typename S>
struct StreamWriter< ::DataFlow::BatchDataProcessorStatus, S>
{
    static void write(S* ostr, const ::DataFlow::BatchDataProcessorStatus& v)
    {
        ostr->write(v.batchIdxStart);
        ostr->write(v.batchSize);
        ostr->write(v.packetTrain);
        ostr->write(v.packetPredict);
        ostr->write(v.tensorInfos);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::BatchDataProcessorStatus, S>
{
    static void read(S* istr, ::DataFlow::BatchDataProcessorStatus& v)
    {
        istr->read(v.batchIdxStart);
        istr->read(v.batchSize);
        istr->read(v.packetTrain);
        istr->read(v.packetPredict);
        istr->read(v.tensorInfos);
    }
};

template<>
struct StreamableTraits< ::DataFlow::ExceptionClosed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::DataFlow::EvtEpoch, S>
{
    static void write(S* ostr, const ::DataFlow::EvtEpoch& v)
    {
        ostr->write(v.epoch);
    }
};

template<typename S>
struct StreamReader< ::DataFlow::EvtEpoch, S>
{
    static void read(S* istr, ::DataFlow::EvtEpoch& v)
    {
        istr->read(v.epoch);
    }
};

}

namespace DataFlow
{

template<class T>
class CallbackNC_DataServer_init : public Callback_DataServer_init_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DataServer_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_DataServer_initPtr
newCallback_DataServer_init(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_initPtr
newCallback_DataServer_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_init<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_DataServer_initPtr
newCallback_DataServer_init(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_initPtr
newCallback_DataServer_init(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_init<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataServer_init : public Callback_DataServer_init_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DataServer_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_DataServer_initPtr
newCallback_DataServer_init(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_initPtr
newCallback_DataServer_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_initPtr
newCallback_DataServer_init(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_initPtr
newCallback_DataServer_init(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_DataServer_getStatus : public Callback_DataServer_getStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::DataFlow::DSStatusPtr&);

    CallbackNC_DataServer_getStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::DSStatusPtr ret;
        try
        {
            ret = proxy->end_getStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_DataServer_getStatusPtr
newCallback_DataServer_getStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::DSStatusPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_getStatusPtr
newCallback_DataServer_getStatus(T* instance, void (T::*cb)(const ::DataFlow::DSStatusPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getStatus<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataServer_getStatus : public Callback_DataServer_getStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::DataFlow::DSStatusPtr&, const CT&);

    Callback_DataServer_getStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::DSStatusPtr ret;
        try
        {
            ret = proxy->end_getStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_DataServer_getStatusPtr
newCallback_DataServer_getStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::DSStatusPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_getStatusPtr
newCallback_DataServer_getStatus(T* instance, void (T::*cb)(const ::DataFlow::DSStatusPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataServer_getBatchDataProcessorStatus : public Callback_DataServer_getBatchDataProcessorStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::DataFlow::BatchDataProcessorStatusPtr&);

    CallbackNC_DataServer_getBatchDataProcessorStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::BatchDataProcessorStatusPtr ret;
        try
        {
            ret = proxy->end_getBatchDataProcessorStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_DataServer_getBatchDataProcessorStatusPtr
newCallback_DataServer_getBatchDataProcessorStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::BatchDataProcessorStatusPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getBatchDataProcessorStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_getBatchDataProcessorStatusPtr
newCallback_DataServer_getBatchDataProcessorStatus(T* instance, void (T::*cb)(const ::DataFlow::BatchDataProcessorStatusPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getBatchDataProcessorStatus<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataServer_getBatchDataProcessorStatus : public Callback_DataServer_getBatchDataProcessorStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::DataFlow::BatchDataProcessorStatusPtr&, const CT&);

    Callback_DataServer_getBatchDataProcessorStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::BatchDataProcessorStatusPtr ret;
        try
        {
            ret = proxy->end_getBatchDataProcessorStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_DataServer_getBatchDataProcessorStatusPtr
newCallback_DataServer_getBatchDataProcessorStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::BatchDataProcessorStatusPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getBatchDataProcessorStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_getBatchDataProcessorStatusPtr
newCallback_DataServer_getBatchDataProcessorStatus(T* instance, void (T::*cb)(const ::DataFlow::BatchDataProcessorStatusPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getBatchDataProcessorStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataServer_putData : public Callback_DataServer_putData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DataServer_putData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_putData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_putData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_putData<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_putData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_putData<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataServer_putData : public Callback_DataServer_putData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DataServer_putData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_putData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_putData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_putData<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_putData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_putDataPtr
newCallback_DataServer_putData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_putData<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_DataServer_getData : public Callback_DataServer_getData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::DataFlow::IODataGetPtr&);

    CallbackNC_DataServer_getData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::IODataGetPtr ret;
        try
        {
            ret = proxy->end_getData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_DataServer_getDataPtr
newCallback_DataServer_getData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::IODataGetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataServer_getDataPtr
newCallback_DataServer_getData(T* instance, void (T::*cb)(const ::DataFlow::IODataGetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataServer_getData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataServer_getData : public Callback_DataServer_getData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::DataFlow::IODataGetPtr&, const CT&);

    Callback_DataServer_getData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::DataFlow::DataServerPrx proxy = ::DataFlow::DataServerPrx::uncheckedCast(result->getProxy());
        ::DataFlow::IODataGetPtr ret;
        try
        {
            ret = proxy->end_getData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_DataServer_getDataPtr
newCallback_DataServer_getData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::DataFlow::IODataGetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataServer_getDataPtr
newCallback_DataServer_getData(T* instance, void (T::*cb)(const ::DataFlow::IODataGetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataServer_getData<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_BatchDataProcessor_onEvent : public Callback_BatchDataProcessor_onEvent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BatchDataProcessor_onEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BatchDataProcessor_onEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BatchDataProcessor_onEvent<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BatchDataProcessor_onEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BatchDataProcessor_onEvent<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_BatchDataProcessor_onEvent : public Callback_BatchDataProcessor_onEvent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BatchDataProcessor_onEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BatchDataProcessor_onEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BatchDataProcessor_onEvent<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BatchDataProcessor_onEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_BatchDataProcessor_onEventPtr
newCallback_BatchDataProcessor_onEvent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BatchDataProcessor_onEvent<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
